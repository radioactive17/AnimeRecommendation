# -*- coding: utf-8 -*-
"""AnimeRecommendation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lkIhhAhpBfhNjXGwmymu3h5PzytRAi2X

#Anime Recommendation

###Importing Libraris
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

"""###Reading the Dataset"""

anime = pd.read_csv('anime.csv')
print(anime.head())

ratings = pd.read_csv('rating.csv')
print(ratings.head())

#Counting the number of users
anime_count = pd.DataFrame(ratings.groupby('user_id').size(), columns = ['count'])
print(users_count)

#Pivoting
anime_user_mat = ratings.pivot(index='anime_id', columns='user_id', values='rating').fillna(0)
print(anime_user_mat)

hashmap = {
            anime: i for i, anime in
            enumerate(list(anime.set_index('anime_id').loc[anime_user_mat.index].name)) # noqa
        }
print(hashmap)

from scipy.sparse import csr_matrix

anime_user_mat_sparse = csr_matrix(anime_user_mat.values)
print(anime_user_mat_sparse)

from sklearn.neighbors import NearestNeighbors
model_knn = NearestNeighbors(metric='cosine', algorithm='brute', n_neighbors=20, n_jobs=-1)

model_knn.fit(anime_user_mat_sparse)

anime_name = input('Enter Anime name:')

!pip install fuzzywuzzy

from fuzzywuzzy import fuzz

match_tuple = []
        # get match
for title, idx in hashmap.items():
    ratio = fuzz.ratio(title.lower(), anime_name.lower())
    if ratio >= 60:
        match_tuple.append((title, idx, ratio))
# sort
match_tuple = sorted(match_tuple, key=lambda x: x[2])[::-1]
if not match_tuple:
    print('Oops! No match is found')
else:
    print('Found possible matches in our database: '
          '{0}\n'.format([x[0] for x in match_tuple]))
idx = match_tuple[0][1]

distances, indices = model_knn.kneighbors(anime_user_mat_sparse[idx],n_neighbors=10+1)

raw_recommends = sorted(list(zip(indices.squeeze().tolist(), distances.squeeze().tolist())), key=lambda x: x[1])[:0:-1]
print(raw_recommends)

reverse_hashmap = {v: k for k, v in hashmap.items()}
print(reverse_hashmap)

for i, (idx, dist) in enumerate(raw_recommends):
            print('{0}: {1}, with distance '
                  'of {2}'.format(i+1, reverse_hashmap[idx], dist))